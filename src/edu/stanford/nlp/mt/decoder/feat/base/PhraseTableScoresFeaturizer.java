package edu.stanford.nlp.mt.decoder.feat.base;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import edu.stanford.nlp.mt.base.FeatureValue;
import edu.stanford.nlp.mt.base.Featurizable;
import edu.stanford.nlp.mt.base.UnknownWordPhraseGenerator;
import edu.stanford.nlp.mt.decoder.feat.RuleFeaturizer;

/**
 * @author danielcer
 * 
 * @param <T>
 */
public class PhraseTableScoresFeaturizer<T> implements
RuleFeaturizer<T, String> {
  private final static String PREFIX = "TM";
  private static final FeatureValue<String> emptyFV = new FeatureValue<String>(
      null, 0.0);

  final Map<String, String[]> featureNamesHash;
  final boolean tagByTable;
  final boolean phraseReweighting;

  private String[] getFeatureNames(String[] phraseScoreNames,
      String phraseTableName) {
    String[] featureNames = new String[phraseScoreNames.length];
    for (int i = 0; i < phraseScoreNames.length; i++) {
      if (phraseScoreNames[i] != null)
        if (!tagByTable) {
          featureNames[i] = String.format("%s:%s", PREFIX, phraseScoreNames[i]);
        } else {
          featureNames[i] = String.format("%s:%s:%s", PREFIX, phraseTableName,
              phraseScoreNames[i]);
        }
    }
    return featureNames;
  }

  /**
   * 
   */
  public PhraseTableScoresFeaturizer() {
    tagByTable = false; // the 'weightedbaseline' featurizer generated by
    // FeaturizerFactory requires this to be set to false
    // so that translation model feature names are predictable
    // without having to know which phrase table they were
    // extracted from
    featureNamesHash = new HashMap<String, String[]>();
    phraseReweighting = false;
  }

  public PhraseTableScoresFeaturizer(boolean tagByTable,
      boolean phraseReweighting) {
    this.tagByTable = tagByTable;
    featureNamesHash = new HashMap<String, String[]>();
    this.phraseReweighting = phraseReweighting;
  }

  @SuppressWarnings("unchecked")
  @Override
  public List<FeatureValue<String>> ruleFeaturize(
      Featurizable<T, String> featurizable) {
    FeatureValue<String>[] featureValues;
    if (featurizable.phraseTableName.equals(UnknownWordPhraseGenerator.PHRASE_TABLE_NAME)) {
      return null;
    }
    if (phraseReweighting) {
      featureValues = new FeatureValue[1];
      String featureName = featurizable.sourcePhrase.toString("DTM:", "_",
          featurizable.targetPhrase.toString("=>", "_"));
      featureValues[0] = new FeatureValue<String>(featureName, 1.0);
    } else {
      // lookup/construct the list of feature names
      String phraseTableName = featurizable.phraseTableName;
      String[] featureNames = featureNamesHash.get(phraseTableName);
      if (featureNames == null) {
        featureNames = getFeatureNames(featurizable.phraseScoreNames,
            phraseTableName);
        featureNamesHash.put(phraseTableName, featureNames);
      }

      // construct array of FeatureValue objects
      featureValues = new FeatureValue[featureNames.length];
      for (int i = 0; i < featureValues.length; i++) {
        featureValues[i] = (i < featurizable.translationScores.length) ? new FeatureValue<String>(
            featureNames[i], featurizable.translationScores[i]) : emptyFV;
      }
    }

    // return the results as a list
    return Arrays.asList(featureValues);
  }

  @Override
  public void initialize() {
  }

  @Override
  public boolean isolationScoreOnly() {
    return false;
  }
}
